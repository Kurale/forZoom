<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Генератор: Деление в столбик</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <style>
        /* --- Стилизация страницы --- */
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f4f4f9;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0;
            padding: 20px;
        }

        /* --- Панель управления --- */
        .controls {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            margin-bottom: 20px;
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            align-items: center;
            justify-content: center;
        }

        select, input, button {
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 16px;
        }

        button {
            background-color: #4CAF50;
            color: white;
            cursor: pointer;
            border: none;
            transition: background 0.3s;
        }

        button:hover {
            background-color: #45a049;
        }

        button.secondary {
            background-color: #2196F3;
        }

        .back-button {
            background-color: #607D8B;
            color: white;
            padding: 10px 20px;
            border-radius: 5px;
            text-decoration: none;
            font-size: 16px;
            transition: background-color 0.3s;
        }
        .back-button:hover {
            background-color: #546E7A;
        }

        /* --- Область "Тетрадный лист" --- */
        #notebook-sheet {
            background-color: white;
            /* Рисуем клетку с помощью CSS градиентов */
            background-image: 
                linear-gradient(#e1e1e1 1px, transparent 1px),
                linear-gradient(90deg, #e1e1e1 1px, transparent 1px);
            background-size: 25px 25px; /* Размер клетки */
            background-position: -1px -1px; /* Выравнивание */
            
            padding: 50px;
            width: 210mm; /* Ширина А4 */
            min-height: 297mm; /* Высота А4 */
            box-shadow: 0 0 15px rgba(0,0,0,0.1);
            box-sizing: border-box;
            
            display: flex;
            flex-wrap: wrap;
            align-content: flex-start;
            gap: 50px; /* Расстояние между примерами */
        }

        /* --- Сам пример --- */
        .problem {
            display: inline-grid;
            /* Размеры ячеек жестко привязаны к клеткам фона */
            grid-template-columns: repeat(auto-fit, 25px);
            grid-auto-rows: 25px;
            font-family: 'Courier New', Courier, monospace; /* Моноширинный шрифт */
            font-size: 20px;
            line-height: 25px;
            color: #333;
        }

        /* Цифра в клетке */
        .cell {
            width: 25px;
            height: 25px;
            text-align: center;
            vertical-align: middle;
            position: relative;
        }

        /* --- Рисование линий "уголка" для деления --- */
        
        /* Вертикальная черта слева (для делителя) */
        .border-left {
            border-left: 2px solid #333;
        }

        /* Горизонтальная черта снизу (для делителя) */
        .border-bottom {
            border-bottom: 2px solid #333;
        }

        /* Класс для скрытия элементов при печати/экспорте, если нужно */
        @media print {
            .controls { display: none; }
            body { background: white; padding: 0; }
            #notebook-sheet { box-shadow: none; margin: 0; }
        }
    </style>
</head>
<body>

    <div class="controls">
        <a href="index.html" class="back-button">В меню</a>
        <div>
            <label>Сложность:</label>
            <select id="difficulty">
                <option value="2-1">2 знака / 1 знак</option>
                <option value="3-1">3 знака / 1 знак</option>
                <option value="3-2">3 знака / 2 знака</option>
                <option value="4-2">4 знака / 2 знака</option>
                <option value="5-2">5 знаков / 2 знака</option>
            </select>
        </div>
        <div>
            <label>Кол-во примеров:</label>
            <input type="number" id="count" value="6" min="1" max="20" style="width: 60px;">
        </div>
        <button onclick="generateExamples()">Сгенерировать</button>
        <button class="secondary" onclick="downloadImage()">Скачать PNG</button>
        <button class="secondary" onclick="exportToSVG()">Скачать SVG</button>
    </div>

    <div id="notebook-sheet"></div>

    <script>
        // --- 1. Математическая логика ---

        // Функция получения случайного числа в диапазоне (min и max включительно)
        function getRandomInt(min, max) {
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }

        // Функция генерации одного примера
        // dividendDigits: кол-во цифр в делимом (A)
        // divisorDigits: кол-во цифр в делителе (B)
        function createMathProblem(dividendDigits, divisorDigits) {
            let dividend, divisor, quotient;
            let attempts = 0;
            
            // Бесконечный цикл (с предохранителем), пока не найдем подходящие числа
            while (true) {
                attempts++;
                if (attempts > 1000) break; // Защита от зависания

                // 1. Генерируем делитель нужной разрядности
                const minDivisor = Math.pow(10, divisorDigits - 1);
                const maxDivisor = Math.pow(10, divisorDigits) - 1;
                divisor = getRandomInt(minDivisor, maxDivisor);

                // 2. Оцениваем диапазон делимого, чтобы попасть в нужную разрядность
                const minDividend = Math.pow(10, dividendDigits - 1);
                const maxDividend = Math.pow(10, dividendDigits) - 1;

                // 3. Вычисляем возможные границы для частного (Ответа)
                const minQuotient = Math.ceil(minDividend / divisor);
                const maxQuotient = Math.floor(maxDividend / divisor);

                if (minQuotient > maxQuotient) continue; // Невозможно подобрать

                // 4. Генерируем случайное частное
                quotient = getRandomInt(minQuotient, maxQuotient);

                // 5. Вычисляем итоговое делимое
                dividend = divisor * quotient;

                // Если всё совпало, выходим из цикла
                if (dividend >= minDividend && dividend <= maxDividend) {
                    break;
                }
            }

            return { dividend, divisor, quotient };
        }

        // --- 2. Логика отрисовки (Render) ---

        function generateExamples() {
            const sheet = document.getElementById('notebook-sheet');
            sheet.innerHTML = ''; // Очищаем лист

            const diff = document.getElementById('difficulty').value.split('-');
            const divDigits = parseInt(diff[0]); // Разрядность делимого
            const divisDigits = parseInt(diff[1]); // Разрядность делителя
            const count = parseInt(document.getElementById('count').value);

            for (let i = 0; i < count; i++) {
                const problemData = createMathProblem(divDigits, divisDigits);
                const problemElement = renderProblem(problemData);
                sheet.appendChild(problemElement);
            }
        }

        // Создание HTML-структуры для одного примера "уголком"
        function renderProblem(data) {
            const container = document.createElement('div');
            container.className = 'problem';

            const dividendStr = data.dividend.toString();
            const divisorStr = data.divisor.toString();
            
            // Нам нужно создать сетку. 
            // Структура деления в столбик:
            // Строка 1: [Цифры делимого] [|] [Цифры делителя]
            // Строка 2: [Пусто.........] [|] [__Черта_____]
            // Вниз нужно добавить пустое место для решения.
            
            // Рассчитываем ширину сетки
            // Ширина = длина делимого + 1 (палка) + длина делителя
            const totalCols = dividendStr.length + 1 + divisorStr.length;
            
            // Задаем CSS Grid стили динамически для этого контейнера
            container.style.gridTemplateColumns = `repeat(${totalCols}, 25px)`;

            // --- РЕНДЕРИНГ ПЕРВОЙ СТРОКИ ---
            
            // 1. Цифры делимого
            for (let char of dividendStr) {
                const cell = document.createElement('div');
                cell.className = 'cell';
                cell.textContent = char;
                container.appendChild(cell);
            }

            // 2. Вертикальная черта (начало уголка)
            // Она находится на стыке, поэтому применим border-left к первой цифре делителя
            // Но чтобы сохранить сеточную структуру, сделаем отдельную ячейку "стенку" или 
            // применим стиль к делителю.
            // Самый надежный способ в CSS Grid: 
            // Просто рендерим делитель, но у его первой цифры будет border-left.
            
            // Разделитель-пустышка не нужен, если мы используем border у ячеек делителя.
            // Но чтобы "уголок" был красивым, лучше использовать border-left на ячейках делителя
            // и border-bottom под ними.

            // Рендерим разделительную вертикальную линию (визуально)
            const separator = document.createElement('div');
            separator.className = 'cell border-left border-bottom'; 
            // Это "пустая" ячейка, которая рисует уголок? Нет, так сложно.
            // Давайте сделаем проще: цифры делителя имеют border-left (первая) и border-bottom (все).
            
            // Поправка: Стандартная запись:
            // 125|5
            //    |-
            //    |25
            
            // Вариант рендеринга:
            // Ячейка-разделитель (вертикальная черта)
            const vBar = document.createElement('div');
            vBar.className = 'cell border-left'; 
            // Она должна занимать высоту 2 ячейки? Нет, в Grid это поток.
            // Чтобы упростить: сделаем wrapper только для верхней части.
            
            // Попробуем линейный рендеринг ячеек:
            
            // --- СТРОКА 1 (Делимое | Делитель) ---
            
            // Добавляем пустую ячейку-разделитель с чертой слева
            const barCell = document.createElement('div');
            barCell.className = 'cell border-left';
            // Чтобы черта шла вниз, она должна быть высокой? 
            // Или используем border-left на самом делителе.
            
            // Переделаем подход к рендерингу для максимальной точности "как в тетради".
            // Будем заполнять Grid ячейка за ячейкой.
            
            // Сбрасываем контейнер, делаем явную сетку
            container.innerHTML = '';
            
            // Определяем высоту области решения (например, длина делимого * 2 строк)
            const rowsNeeded = (dividendStr.length * 2) + 2; 

            // Заполняем первую строку
            // Делимое
            for (let char of dividendStr) {
                let cell = createCell(char);
                container.appendChild(cell);
            }
            
            // Разделитель (вертикальная палка)
            // Мы сделаем "виртуальный" столбец для палки.
            // Или просто применим стиль к следующей ячейке.
            // Давайте применим стиль к ПЕРВОЙ цифре делителя.
            
            // Делитель
            for (let i = 0; i < divisorStr.length; i++) {
                let cell = createCell(divisorStr[i]);
                cell.classList.add('border-bottom'); // Черта снизу делителя
                if (i === 0) {
                    cell.classList.add('border-left'); // Черта слева от делителя
                    // Увеличим высоту border-left, чтобы она закрывала и вторую строку?
                    // В CSS Grid сложно "вытянуть" бордер.
                    // Лучше использовать псевдоэлемент или rowspan, но rowspan сложен в авто-генерации.
                }
                container.appendChild(cell);
            }

            // --- СТРОКИ ДЛЯ РЕШЕНИЯ (Пустые клетки) ---
            // Заполняем пустыми клетками оставшееся пространство, чтобы держать сетку
            // Всего ячеек = (rowsNeeded - 1) * totalCols
            // Но нам важно, чтобы вертикальная черта продолжалась?
            // Обычно в школе пишут черту только возле делителя и под ним. Длинная черта вниз не обязательна.
            // Но если нужна черта под делителем для ответа?
            
            // Добавим "пустое место" для ответа под делителем
            // Это вторая строка. 
            // Слева (под делимым) пусто. Справа (под делителем) пусто для ответа.
            
            // Чтобы пользователю было удобно, создадим просто сетку пустых ячеек вниз.
            const totalCells = totalCols * rowsNeeded;
            const cellsCreatedSoFar = dividendStr.length + divisorStr.length;
            
            // Вторая строка - добавляем короткую вертикальную линию под делителем
            for(let k = 0; k < totalCols; k++) {
                 let emptyCell = createCell('');
                  // Добавляем короткую вертикальную линию на одну клетку правее от делителя
                  if (k === dividendStr.length + 1) {
                      emptyCell.classList.add('border-left');
                  }
                  container.appendChild(emptyCell);
            }
            
            // Остальные строки решения - просто пустые клетки
            for(let k = 0; k < (totalCols * 9); k++) { // 9 строк запаса
                 let emptyCell = createCell('');
                  container.appendChild(emptyCell);
            }

            return container;
        }

        function createCell(content) {
            const div = document.createElement('div');
            div.className = 'cell';
            div.textContent = content;
            // Делаем ячейки редактируемыми для цифрового использования!
            // Но только если там нет исходных цифр (или все?)
            // Лучше пустые сделать редактируемыми.
            if (content === '') {
                div.contentEditable = true; 
            }
            return div;
        }

        // --- 3. Экспорт ---
        
        async function downloadImage() {
            const sheet = document.getElementById('notebook-sheet');
            
            // html2canvas делает "снимок" DOM элемента
            const canvas = await html2canvas(sheet, {
                scale: 2, // Улучшаем качество (Retina like)
                backgroundColor: null // Прозрачность или белый
            });

            const link = document.createElement('a');
            link.download = 'math-examples.png';
            link.href = canvas.toDataURL('image/png');
            link.click();
        }

/**
 * Основная функция для экспорта текущих примеров в SVG.
 * Генерирует один общий SVG файл, где примеры расположены друг под другом.
 */
function exportToSVG() {
    const diff = document.getElementById('difficulty').value.split('-');
    const divDigits = parseInt(diff[0]);
    const divisDigits = parseInt(diff[1]);
    const count = parseInt(document.getElementById('count').value);
    
    // Настройки сетки
    const cellSize = 25;
    const padding = 50; // Отступ от краев
    const rowsForSolution = 10; // Запас клеток вниз
    const problemGap = 50; // Расстояние между примерами по вертикали
    const problemGapX = 50; // Расстояние между примерами по горизонтали
    const examplesPerRow = 3; // Количество примеров в ряду

    // Высота и ширина одного примера
    const problemHeight = (1 + rowsForSolution) * cellSize;
    const problemWidth = (divDigits + divisDigits) * cellSize;
    
    // Количество рядов
    const rows = Math.ceil(count / examplesPerRow);
    
    // Размеры SVG
    const totalSvgWidth = problemWidth * examplesPerRow + problemGapX * (examplesPerRow - 1) + padding * 2;
    const totalSvgHeight = problemHeight * rows + problemGap * (rows - 1) + padding * 2;

    // Начало формирования строки SVG
    let svgContent = `<svg xmlns="http://www.w3.org/2000/svg" width="${totalSvgWidth}" height="${totalSvgHeight}" viewBox="0 0 ${totalSvgWidth} ${totalSvgHeight}">`;
    
    // Стили для текста и линий
    svgContent += `
    <style>
        .cell-text { font: 20px 'Courier New', monospace; fill: #333; text-anchor: middle; dominant-baseline: central; }
        .grid-line { stroke: #e1e1e1; stroke-width: 1; }
        .division-line { stroke: #333; stroke-width: 2; fill: none; }
    </style>`;

    // Генерируем данные для тех же примеров, что сейчас на экране (или новые)
    // Для простоты здесь генерируются новые данные по тем же настройкам
    for (let i = 0; i < count; i++) {
        const data = createMathProblem(divDigits, divisDigits);
        const row = Math.floor(i / examplesPerRow);
        const col = i % examplesPerRow;
        const xOffset = padding + col * (problemWidth + problemGapX);
        const yOffset = padding + row * (problemHeight + problemGap);
        
        svgContent += generateSingleProblemSVG(data, xOffset, yOffset, cellSize, rowsForSolution);
    }

    svgContent += `</svg>`;

    // Создаем ссылку для скачивания
    const blob = new Blob([svgContent], {type: 'image/svg+xml;charset=utf-8'});
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = 'examples.svg';
    link.click();
}

/**
 * Рисует один пример в формате SVG
 * @param {Object} data - Объект с делимым и делителем
 * @param {number} yOffset - Смещение примера по вертикали на общем холсте
 */
function generateSingleProblemSVG(data, xOffset, yOffset, cellSize, rows) {
    const divStr = data.dividend.toString();
    const divisStr = data.divisor.toString();
    const totalCols = divStr.length + divisStr.length;
    const extraCols = 3; // Добавляем 3 пустых колонки справа
    const totalColsWithExtra = totalCols + extraCols;
    
    let g = `<g transform="translate(${xOffset}, ${yOffset})">`; // Контейнер для одного примера

    // 1. Рисуем сетку (11 строк вниз, но шире на 3 колонки)
    for (let r = 0; r <= rows + 1; r++) {
        const y = r * cellSize;
        g += `<line x1="0" y1="${y}" x2="${totalColsWithExtra * cellSize}" y2="${y}" class="grid-line" />`;
    }
    for (let c = 0; c <= totalColsWithExtra; c++) {
        const x = c * cellSize;
        g += `<line x1="${x}" y1="0" x2="${x}" y2="${(rows + 1) * cellSize}" class="grid-line" />`;
    }

    // 2. Рисуем цифры делимого
    for (let i = 0; i < divStr.length; i++) {
        const x = i * cellSize + cellSize / 2;
        const y = cellSize / 2;
        g += `<text x="${x}" y="${y}" class="cell-text">${divStr[i]}</text>`;
    }

    // 3. Рисуем цифры делителя
    const divisorStartX = divStr.length;
    for (let i = 0; i < divisStr.length; i++) {
        const x = (divisorStartX + i) * cellSize + cellSize / 2;
        const y = cellSize / 2;
        g += `<text x="${x}" y="${y}" class="cell-text">${divisStr[i]}</text>`;
    }

    // 4. Рисуем "Уголок"
    // Вертикальная линия (между делимым и делителем)
    const vX = divStr.length * cellSize;
    g += `<line x1="${vX}" y1="0" x2="${vX}" y2="${cellSize * 2}" class="division-line" />`;
    
    // Горизонтальная линия (под делителем)
    const hY = cellSize;
    const hX1 = vX;
    const hX2 = totalCols * cellSize;
    g += `<line x1="${hX1}" y1="${hY}" x2="${hX2}" y2="${hY}" class="division-line" />`;

    g += `</g>`;
    return g;
}

        // Инициализация при загрузке
        generateExamples();

    </script>
</body>
</html>